"""
TITLE: cruise_030623-pdf
DESCRIPTION: A Cruise autonomous vehicle ("Cruise AV"), operating in driverless autonomous mode, was at a complete stop in response to a red light on northbound Polk Street at the intersection with Sutter Street. The Cruise AV began to proceed as the light turned green when an Infiniti Q50 passed the Cruise AV in the oncoming traffic lane and began performing “donuts” in the intersection. The Cruise AV began to initiate a left turn onto Sutter Street when the Infiniti Q50 made contact with the Cruise AV’s front driver side bumper, causing damage to the front driver side bumper, front driver side fascia and front driver side headlight. The driver of the Infiniti Q50 left the scene without exchanging information. There were no reported injuries and the Cruise AV was towed from the incident.
SOURCE: California DMV Crash Reports
GENERATED BY: Gemini-2.5-Flash
"""

#################################
# MAP AND MODEL                 #
#################################

param map = localPath('../../maps/Town05.xodr')
model scenic.simulators.metadrive.model
param POLICY = 'built_in'

#################################
# CONSTANTS                     #
#################################

CRUISE_AV_MODEL = 'vehicle.lincoln.mkz_2017'
INFINITI_MODEL = 'vehicle.audi.tt'

param EGO_SPEED_PROCEED = VerifaiRange(2.5, 3.5)
param EGO_BRAKE = VerifaiRange(0.5, 1.0)
EGO_DIST_TO_INTERSECTION = [5, 10]

param ADV_SPEED_PASSING = VerifaiRange(10, 15)
ADV_DIST_TO_INTERSECTION = [35, 45]

param SAFETY_DIST = VerifaiRange(3, 5)
CRASH_DIST = 1
TERM_DIST = 50

#################################
# AGENT BEHAVIORS               #
#################################

behavior EgoBehavior(trajectory):
    for i in range(30):
        wait
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.EGO_SPEED_PROCEED, trajectory=trajectory)
    interrupt when withinDistanceToAnyObjs(self, globalParameters.SAFETY_DIST):
        take SetBrakeAction(globalParameters.EGO_BRAKE)

behavior DonutBehavior():
    while True:
        take SetThrottleAction(1.0), SetSteerAction(-1.0)


behavior InfinitiBehavior(trajectory):
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.ADV_SPEED_PASSING, trajectory=trajectory)
    interrupt when (distance from self to intersection) <= 0:
        do DonutBehavior()

#################################
# SPATIAL RELATIONS             #
#################################

intersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))

egoInitLane = Uniform(*filter(lambda l: all([sec._slowerLane is not None for sec in l.sections]), intersection.incomingLanes))
egoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, egoInitLane.maneuvers))

egoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]
egoSpawnPt = new OrientedPoint in egoInitLane.centerline

#################################
# SCENARIO SPECIFICATION        #
#################################

if globalParameters.POLICY == 'metadrive_ppo' or globalParameters.POLICY == 'ppo_with_built_in':
    from metadrive_expert import MetaDrivePPOPolicyCar, MetaDrivePPOPolicyBehavior, MetaDrivePPOUpdateState
    behavior EgoPPOBehavior(trajectory):
        for i in range(30):
            wait
        do MetaDrivePPOPolicyBehavior(trajectory)
    ego = new MetaDrivePPOPolicyCar at egoSpawnPt,
        with blueprint CRUISE_AV_MODEL,
        with behavior EgoPPOBehavior(egoTrajectory)
    require monitor MetaDrivePPOUpdateState()
else:
    ego = new Car at egoSpawnPt,
        with blueprint CRUISE_AV_MODEL,
        with behavior EgoBehavior(egoTrajectory)


advInitLane = ego.laneSection.slowerLane.lane
advManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, advInitLane.maneuvers))
advTrajectory = [advInitLane, advManeuver.connectingLane]
advSpawnPt = new OrientedPoint in advInitLane.centerline

adversary = new Car at advSpawnPt,
    with blueprint INFINITI_MODEL,
    with behavior InfinitiBehavior(advTrajectory)

require EGO_DIST_TO_INTERSECTION[0] <= (distance to intersection) <= EGO_DIST_TO_INTERSECTION[1]
require ADV_DIST_TO_INTERSECTION[0] <= (distance from adversary to intersection) <= ADV_DIST_TO_INTERSECTION[1]
#require (distance from adversary to ego) > CRASH_DIST

#terminate when (distance to adversary) < (ego.length + adversary.length) / 2
#terminate when (distance from ego to egoSpawnPt) > TERM_DIST

from rulebook_benchmark import bench
require monitor bench.bench()
record ego in egoTrajectory[-1] as egoReachedGoal