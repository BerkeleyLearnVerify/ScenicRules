"""
TITLE: cruise_032223_2-pdf
DESCRIPTION: A Cruise autonomous vehicle (“Cruise AV”), operating in driverless autonomous mode, was traveling southbound on Shafter Avenue between Ingalls Street and Hawes Street. Shortly after the intersection with Ingalls Street, the Cruise AV made contact with a tow dolly attached to the back of a double-parked truck, damaging the front passenger side bumper and front passenger side fender of the Cruise AV. There were no reported injuries.
SOURCE: California DMV Crash Reports
GENERATED BY: Gemini-2.5-Flash
"""

#################################
# MAP AND MODEL                 #
#################################

param map = localPath('../../maps/Town04.xodr')
model scenic.simulators.metadrive.model
param POLICY = 'built_in'

#################################
# CONSTANTS                     #
#################################

CRUISE_AV_MODEL = 'vehicle.lincoln.mkz_2017'
TRUCK_MODEL = 'vehicle.mercedes.sprinter' # A large van/truck model
DOLLY_MODEL = 'vehicle.audi.etron' # Placeholder model for a tow dolly

param CRUISE_AV_SPEED = VerifaiRange(5, 8) # Cruise AV speed in m/s
param TRUCK_OFFSET_LATERAL = VerifaiRange(1.0, 2.0) # Lateral offset for "double-parked" from lane centerline
param DOLLY_ATTACH_DIST = VerifaiRange(1.0, 3.0) # Distance from the back of the truck to the front of the dolly


EGO_INTERSECTION_DISTANCE = 15
TRUCK_INTERSECTION_DISTANCE = 20
param SAFETY_DIST = VerifaiRange(3, 5)
param EGO_BRAKE = VerifaiRange(0.5, 1.0)
param TRUCK_OFFSET_X = VerifaiRange(1, 1.5)


#################################
# AGENT BEHAVIORS               #
#################################

behavior EgoBehavior(trajectory):
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.CRUISE_AV_SPEED, trajectory=trajectory)
    interrupt when withinDistanceToAnyObjs(self, globalParameters.SAFETY_DIST):
        take SetBrakeAction(globalParameters.EGO_BRAKE)

#################################
# SPATIAL RELATIONS             #
#################################

# Find an intersection to set up the "shortly after intersection" condition
intersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))

# Ego's entry lane and maneuver to go straight through the intersection
egoEntryLane = Uniform(*filter(lambda l: all(sec._slowerLane is None and sec._fasterLane is None for sec in l.sections), intersection.incomingLanes))
egoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, egoEntryLane.maneuvers))
egoTrajectory = [egoEntryLane, egoManeuver.connectingLane, egoManeuver.endLane]
egoSpawnPt = new OrientedPoint in egoEntryLane

# Truck's lane: after the intersection, specifically in the lane the ego exits into
truckLane = egoManeuver.endLane
truckSpawnPt = new OrientedPoint in truckLane.centerline



#################################
# SCENARIO SPECIFICATION        #
#################################

if globalParameters.POLICY == 'metadrive_ppo' or globalParameters.POLICY == 'ppo_with_built_in':
    from metadrive_expert import MetaDrivePPOPolicyCar, MetaDrivePPOPolicyBehavior, MetaDrivePPOUpdateState
    ego = new MetaDrivePPOPolicyCar at egoSpawnPt,
        with blueprint CRUISE_AV_MODEL,
        with behavior MetaDrivePPOPolicyBehavior(egoTrajectory)
    require monitor MetaDrivePPOUpdateState()
else:
    ego = new Car at egoSpawnPt,
        with blueprint CRUISE_AV_MODEL,
        with behavior EgoBehavior(egoTrajectory)

truck = new Car at truckSpawnPt offset by (globalParameters.TRUCK_OFFSET_X, 0),
    with blueprint TRUCK_MODEL # Truck is stationary, double-parked

# Dolly is positioned behind the truck
dollySpawnPt = new OrientedPoint behind truck by globalParameters.DOLLY_ATTACH_DIST

dolly = new Car at dollySpawnPt,
    with blueprint DOLLY_MODEL, facing truck # Dolly is stationary, attached to the back of the truck

#################################
# REQUIREMENTS                  #
#################################

# Ensure ego is positioned before the intersection
#require EGO_INIT_POS_BEFORE_INTERSECTION_MIN <= (distance from cruise_av to intersection) <= EGO_INIT_POS_BEFORE_INTERSECTION_MAX
# Ensure the truck and dolly are initially not in contact with the cruise_av
#require (distance from cruise_av to truck) > (cruise_av.length + truck.length) / 2
#require (distance from cruise_av to dolly) > (cruise_av.length + dolly.length) / 2
require (distance from ego to intersection) < EGO_INTERSECTION_DISTANCE
require (distance from truck to intersection) < TRUCK_INTERSECTION_DISTANCE
# Termination condition: contact with the tow dolly
#terminate when (distance from ego to dolly) < (ego.length + dolly.length) / 2
# Terminate if ego travels too far without incident (to prevent infinite simulation)
#terminate when (distance from ego to egoSpawnPt) > TERM_TRAVELED_DIST

from rulebook_benchmark import bench
require monitor bench.bench()
record ego in egoTrajectory[-1] as egoReachedGoal
