"""
TITLE: cruise_07302023-pdf
DESCRIPTION: A Cruise autonomous vehicle (“AV”), operating in driverless autonomous mode, was traveling northbound on Mission Street between Virginia Avenue and 29th Street. As the AV was yielding to oncoming traffic in preparation to make a left turn onto westbound 29th Street on a green light, a dark-colored BMW Sedan traveling behind the AV failed to stop and rear-ended the AV, damaging the rear passenger side bumper fascia and rear passenger side wheel molding of the AV. The driver of the dark-colored BMW Sedan left the scene without exchanging information. There were no reported injuries.
SOURCE: California DMV Crash Reports
GENERATED BY: Gemini-2.5-Flash
"""

#################################
# MAP AND MODEL                 #
#################################

param map = localPath('../../maps/Town04.xodr')
model scenic.simulators.metadrive.model
param POLICY = 'built_in'

#################################
# CONSTANTS                     #
#################################

MODEL_AV = 'vehicle.lincoln.mkz_2017'
MODEL_BMW = 'vehicle.bmw.grandtourer'

param EGO_SPEED = VerifaiRange(0.5, 3.0)
param ADV_SPEED = VerifaiRange(8, 12)
param ADV_DIST_FROM_EGO = VerifaiRange(-15, -20)

param SAFETY_DIST = VerifaiRange(3, 5)
param EGO_BRAKE = VerifaiRange(0.5, 1.0)
CRASH_DIST = 1
INIT_DIST = [15, 20]
TERM_DIST = 70

#################################
# AGENT BEHAVIORS               #
#################################

behavior EgoBehavior(trajectory):
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.EGO_SPEED, trajectory=trajectory)
    interrupt when withinDistanceToAnyObjs(self, globalParameters.SAFETY_DIST):
        take SetBrakeAction(globalParameters.EGO_BRAKE)

#################################
# SPATIAL RELATIONS             #
#################################

intersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))

egoInitLane = Uniform(*intersection.incomingLanes)
egoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, egoInitLane.maneuvers))
advManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, egoInitLane.maneuvers))
egoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]

egoSpawnPt = new OrientedPoint in egoInitLane.centerline

advSpawnPt = new OrientedPoint following roadDirection from egoSpawnPt for globalParameters.ADV_DIST_FROM_EGO
advTrajectory = [egoInitLane, advManeuver.connectingLane, advManeuver.endLane]

#################################
# SCENARIO SPECIFICATION        #
#################################

if globalParameters.POLICY == 'metadrive_ppo' or globalParameters.POLICY == 'ppo_with_built_in':
    from metadrive_expert import MetaDrivePPOPolicyCar, MetaDrivePPOPolicyBehavior, MetaDrivePPOUpdateState
    ego = new MetaDrivePPOPolicyCar at egoSpawnPt,
        with blueprint MODEL_AV,
        with behavior MetaDrivePPOPolicyBehavior(egoTrajectory)
    require monitor MetaDrivePPOUpdateState()
else:
    ego = new Car at egoSpawnPt,
        with blueprint MODEL_AV,
        with behavior EgoBehavior(egoTrajectory)

adversary = new Car at advSpawnPt,
    with blueprint MODEL_BMW,
    with behavior FollowTrajectoryBehavior(target_speed=globalParameters.ADV_SPEED, trajectory=advTrajectory)

#require INIT_DIST[0] <= (distance to intersection) <= INIT_DIST[1]
#require INIT_DIST[0] <= (distance from adversary to intersection) <= INIT_DIST[1]
#terminate when (distance to adversary) < (ego.length + adversary.length) / 2
require adversary.lane == ego.lane

from rulebook_benchmark import bench
require monitor bench.bench()
record ego in egoTrajectory[-1] as egoReachedGoal
