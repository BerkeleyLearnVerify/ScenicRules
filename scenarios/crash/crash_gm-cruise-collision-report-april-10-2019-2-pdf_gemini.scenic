"""
TITLE: gm-cruise-collision-report-april-10-2019-2-pdf
DESCRIPTION: A Cruise autonomous vehicle (“Cruise AV”), operating in autonomous mode, was approaching the intersection prior to making a left turn from southbound Lyon Street onto eastbound California Street when the Cruise AV yielded to an overtaking vehicle on its left proceeding straight on southbound Lyon. Once the overtaking vehicle completed its pass, the Cruise AV attempted to continue its left turn when another vehicle directly behind the Cruise AV, attempting to turn right on California, made contact with the Cruise AV’s right rear bumper, damaging the bumper. There were no injuries and police were not called.
SOURCE: California DMV Crash Reports
GENERATED BY: Gemini-2.5-Flash
"""

#################################
# MAP AND MODEL                 #
#################################

param map = localPath('../../maps/Town04.xodr')
model scenic.simulators.metadrive.model
param POLICY = 'built_in'

#################################
# CONSTANTS                     #
#################################

MODEL = 'vehicle.lincoln.mkz_2017'

param EGO_SPEED_APPROACH = VerifaiRange(8, 10) # Speed approaching intersection before yielding
param EGO_SPEED_TURN = VerifaiRange(3, 5)     # Speed during left turn after yielding
param EGO_BRAKE = VerifaiRange(0.5, 1.0)      # Brake intensity for ego when yielding
param SAFETY_DIST = VerifaiRange(3, 5)        # Distance to trigger safety braking

param ADV1_SPEED = VerifaiRange(10, 12)       # Speed for overtaking vehicle (faster than ego's approach speed)
param ADV2_SPEED = VerifaiRange(5, 7)         # Speed for vehicle behind (could be faster than ego's turn speed)

param EGO_INIT_DIST = VerifaiRange(15, 25)    # Initial distance of ego from the intersection
param ADV1_DIST_BEHIND_EGO = VerifaiRange(-15, -20) # Initial distance of adversary1 behind ego
param ADV2_DIST_BEHIND_EGO = VerifaiRange(-35, -40)  # Initial distance of adversary2 behind ego

param EGO_APPROACH_DIST = VerifaiRange(0, 5) # Distance from intersection when ego starts to slow/yield
param OVERTAKE_COMPLETED_DIST = VerifaiRange(10, 15) # Distance adv1 must be ahead of ego for ego to resume turn


EGO_INTERSECTION_DIST = VerifaiRange(10, 15)
ADV1_INTERSECTION_DIST = VerifaiRange(20, 30)
ADV2_INTERSECTION_DIST = VerifaiRange(40, 50)


TERM_DIST = 70 # Distance ego travels from its spawn point to terminate the scenario
COLLISION_BUFFER = 2.0 # Factor for collision detection (e.g., sum of lengths / 2 for overlap)

#################################
# AGENT BEHAVIORS               #
#################################

behavior StoppingBehavior():
    while True:
        take SetThrottleAction(0.0)
        take SetBrakeAction(1.0)

behavior EgoBehavior(trajectory):
    # Stage 1: Approach the intersection and prepare to turn
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.EGO_SPEED_APPROACH, trajectory=trajectory) until (distance to intersection) < globalParameters.EGO_APPROACH_DIST
        print("Ego preparing to yield.")
        do StoppingBehavior() for 2 seconds
        print("Ego resuming left turn.")
        do FollowTrajectoryBehavior(target_speed=globalParameters.EGO_SPEED_TURN, trajectory=trajectory)
    interrupt when withinDistanceToAnyObjs(self, globalParameters.SAFETY_DIST):
        take SetBrakeAction(globalParameters.EGO_BRAKE)


behavior Adv1Behavior(lane):
    # Adversary 1 follows its straight trajectory at a higher speed to overtake ego.
    do FollowLaneBehavior(target_speed=globalParameters.ADV1_SPEED, is_oppositeTraffic=True) until distance from self to intersection == 0
    do FollowLaneBehavior(target_speed=globalParameters.ADV1_SPEED, is_oppositeTraffic=True, laneToFollow=lane)

behavior Adv2Behavior(trajectory):
    # Adversary 2 follows its right turn trajectory.
    do FollowTrajectoryBehavior(target_speed=globalParameters.ADV2_SPEED, trajectory=trajectory)

#################################
# SPATIAL RELATIONS             #
#################################

intersection = Uniform(*filter(lambda i: i.is4Way, network.intersections))

# Ego's initial lane and trajectory (left turn)
# Filters for an incoming lane that supports a left turn maneuver.
egoInitLane = Uniform(*filter(lambda lane: any(m.type is ManeuverType.LEFT_TURN for m in lane.maneuvers), intersection.incomingLanes))
egoManeuver = Uniform(*filter(lambda m: m.type is ManeuverType.LEFT_TURN, egoInitLane.maneuvers))
adv1EndLane = egoManeuver.endLane.sections[0].laneToLeft.lane
adv1Maneuver = Uniform(*filter(lambda m: m.type is ManeuverType.STRAIGHT, adv1EndLane.maneuvers))

egoTrajectory = [egoInitLane, egoManeuver.connectingLane, egoManeuver.endLane]
start = new OrientedPoint on egoInitLane.centerline

#################################
# SCENARIO SPECIFICATION        #
#################################

if globalParameters.POLICY == 'metadrive_ppo' or globalParameters.POLICY == 'ppo_with_built_in':
    from metadrive_expert import MetaDrivePPOPolicyCar, MetaDrivePPOPolicyBehavior, MetaDrivePPOUpdateState
    behavior EgoPPOBehavior(trajectory):
        do MetaDrivePPOPolicyBehavior(trajectory) until (distance to intersection) < globalParameters.EGO_APPROACH_DIST
        do StoppingBehavior() for 2 seconds
        do MetaDrivePPOPolicyBehavior(trajectory)
    ego = new MetaDrivePPOPolicyCar in egoInitLane.centerline,
        with blueprint MODEL,
        with behavior EgoPPOBehavior(egoTrajectory)
    require monitor MetaDrivePPOUpdateState()
else:
    ego = new Car in egoInitLane.centerline,
        with blueprint MODEL,
        with behavior EgoBehavior(egoTrajectory)

# Adversary 1's initial lane and trajectory (straight, to ego's left)
# Assumes adv1 is in the lane to the left (fasterLane) of ego's lane.
adv1InitLane = ego.laneSection.laneToLeft.lane
# adv1 is initially placed behind ego in its own lane for overtaking.

# Adversary 2's initial lane and trajectory (right turn, behind and to ego's right)
# Assumes adv2 is in the lane to the right (slowerLane) of ego's lane.
adv2InitLane = egoInitLane
adv2Maneuver = Uniform(*filter(lambda m: m.type is ManeuverType.RIGHT_TURN, adv2InitLane.maneuvers))
adv2Trajectory = [adv2InitLane, adv2Maneuver.connectingLane, adv2Maneuver.endLane]
# adv2 is initially placed behind ego in its own lane.
adv2SpawnPt = new OrientedPoint following roadDirection from ego for globalParameters.ADV2_DIST_BEHIND_EGO

adversary1 = new Car in not visible adv1InitLane.centerline,
    with blueprint MODEL,
    facing ego,
    with behavior Adv1Behavior(adv1Maneuver.connectingLane)

adversary2 = new Car in not visible egoInitLane.centerline,
    with blueprint MODEL,
    with behavior Adv2Behavior(adv2Trajectory)

#################################
# REQUIREMENTS                  #
#################################

require EGO_INTERSECTION_DIST - 10 < (distance to intersection) < EGO_INTERSECTION_DIST
require ADV1_INTERSECTION_DIST - 10 < (distance from adversary1 to intersection) < ADV1_INTERSECTION_DIST
require ADV2_INTERSECTION_DIST - 10 < (distance from adversary2 to intersection) < ADV2_INTERSECTION_DIST

from rulebook_benchmark import bench
require monitor bench.bench()
record ego in egoTrajectory[-1] as egoReachedGoal